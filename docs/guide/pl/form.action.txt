Tworzenie akcji
===============

Kiedy mamy już model, możemy rozpocząc pisanie logiki, którą potrzebujemy aby 
manipulować modelem. Umieszczamy tą logikę wewnątrz kontrolera akcji. Na przykład, 
dla logowania, potrzebujemy następującego kodu:

~~~
[php]
public function actionLogin()
{
	$form=new LoginForm;
	if(isset($_POST['LoginForm']))
	{
		// zbierz dane wejściowe od użytkownika
		$form->attributes=$_POST['LoginForm'];
		// sprawdz poprawność danych wejściowych oraz przekieruj do poprzedniej strony jeśli 
		// walidacja powiedzie się
		if($form->validate())
			$this->redirect(Yii::app()->user->returnUrl);
	}
	// wyświetl formularz logowania
	$this->render('login',array('user'=>$form));
}
~~~

W powyższym przykładzie na początku utworzyliśmy instancję `LoginForm`; gdy żądanie 
jest żądaniem POST (co oznacza, że dane z formularza logowania zostały przesłane), 
wypełniamy `$form` przesłanymi danymi z `$_POST['LoginForm']`; następnie sprawdzamy 
poprawność danych wejściowych i jeśli są poprawne, przekierowujemy przeglądarkę użytkownika
na stronę, która poprzednio wymagała uwierzytelnienia. W przypadku gdy walidacja nie powiedzie się,
albo gdy akcja wywoływana jest po raz pierwszy generujemy widok `login`, którego 
zawartość będzie opisana w następnej sekcji.

> Tip|Porada: Podczas akcji `login` używamy `Yii::app()->user->returnUrl` aby otrzymać
adres URL strony, która wymagała uwierzytelnienia. Komponent `Yii::app()->user` jest typu [CWebUser] 
(lub jego klasy potomne)i reprezentuje dane sesyjne użytkownika (np. nazwę użytkownika, 
status). Aby otrzymać więcej informacji zobacz [Uwierzytelnienie i autoryzację](/doc/guide/topics.auth).

Przyjrzyjmy się uważnie następującemu wyrażeniu PHP, które pojawia się w akcji 
logowania `login`:

~~~
[php]
$form->attributes=$_POST['LoginForm'];
~~~

Tak jak napisaliśmy w [ochronie przypisania atrybutów](/doc/guide/form.model#securing-attribute-assignments),
ta linia kodu wypełnia model danymi przesłanymi przez użytkownika. Właściwość 
`attributes` jest definiowana przez klasę [CModel] i oczekuje tablicy par nazwa-wartość, 
które potem przupisuje do każdej wartości atrybutu odpowiedniego modelu. 
Zatem, jeśli `$_POST['LoginForm']` zwróci nam taką tablicę, powyższy kod będzie 
równoznaczny do następującego, długiego kodu (zakładając ze każdy wymagany atrybut 
jest obecny w tablicy):

~~~
[php]
$form->username=$_POST['LoginForm']['username'];
$form->password=$_POST['LoginForm']['password'];
$form->rememberMe=$_POST['LoginForm']['rememberMe'];
~~~

> Note|Przypis: Aby umożliwić `$_POST['LoginForm']` zwracanie tablicy zamiast łańcucha znaków, 
pozostajemy przy pewnej konwencji podczas nazywania pól wejściowych w widoku. 
W szczególności, dla pól wejściowych odpowiadających atrybutowi `a` modelu klasy `C`
nazywamy go `C[a]`. Na przykład, użyjemy `LoginForm[username]` aby nazwać pole wejściowe 
odpowiadające atrybutowi `username`.

Zadanie jaki nam pozostało, to utworzenie widoku `login`, który powinien zawierać 
formularz HTML wraz z wymaganymi polami wejściowymi.

<div class="revision">$Id: form.action.txt 626 2009-02-04 20:51:13Z qiang.xue $</div>