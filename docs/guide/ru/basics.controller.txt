Контроллер (Controller)
=======================

`Контроллер (controller)` - это экземпляр класса [CController] или производного от него. 
Контроллер создается приложением в случае, когда пользователь его запрашивает. При запуске контроллер
исполняет соответствующий экшн (action), что обычно подразумевает создание соответствующих моделей и рендеринг
необходимых представлений. Попросту говоря, `экшн (action)` - это метод класса контроллера, название которого начинается
на `action`.

У контроллера имеется экшн, исполняемый по умолчанию. В случае, когда пользователь не указывает требуемый экшн при запросе,
будет выполнен экшн по умолчанию. Такой экшн по умолчанию имеет название `index`. Это может быть изменено путем установки 
значения [CController::defaultAction].

Ниже приведен минимальный код класса контроллера. Так как контроллер не определеят ни одного экшна, обращение к нему
приведет к вызову исключения (exception).

~~~
[php]
class SiteController extends CController
{
}
~~~


Путь (Route)
------------

Контроллеры и экшны опознаются по ихним идентификаторам (ID). Идентификатор контроллера - запись формата `path.to.xyz`, указывающая
расположение класса контроллера `protected/controllers/path/to/XyzController.php`, где токен `xyz` следует заменить реальным именем 
(так например, `post` соотностится с `protected/controllers/PostController.php`). Идентификатор экшна - это название метода без
префикса `action`. Например, если класс контроллера содержит метод `actionEdit`, то идентификатор соответствующего экшна - `edit`.

Пользователь запрашивает некоторый контроллер и экшн в указании пути. Путь формируется объединением идентификаторов контроллера и экшна,
разделенными слэшем. Например, путь `post/edit` указывает на экшн `edit` контроллера `PostController`
По умолчанию, URL `http://hostname/index.php?r=post/edit` приведет к вызову именно этих контроллера и экшна. 

>Note: По умлочанию пути зависимы от регистра. Начиная с версии 1.0.1 это возможно изменить путем установки [CUrlManager::caseSensitive] в
>false в конфигурации приложения. В режиме, нечувствительном к регистру, убедитесь, что названия директорий, содержащих файлы классов
>контроллеров - в нижнем регистре, а также что в [controller map|CWebApplication::controllerMap] и [action map|CController::actions] 
>используются ключи только в нижнем регистре.

Создание экземпляра контроллера
-------------------------------
Экземпляр контроллера создается, когда [CWebApplication] обрабатывает входящий запрос.
Имея идентификатор контроллера, приложение использует следующие правила для определения класса контроллера и того, где он расположен:

   - Если сконфигурировано свойство [CWebApplication::catchAllRequest], контроллер будет создан на основании этой конфигурации, а контроллер
запрошенный пользователем будет проигнорирован. Этот подход, в частности, используется для установки приложения в режим технических работ (maintenance) и отображения статической страницы с соответствующим сообщением.

   - Если идентификатор контроллера обнаружен в [CWebApplication::controllerMap], соответствующая конфигурация контроллера будет использована
для создания экземпляра контроллера.

   - Если идентификатор контроллера в формате `'path.to.xyz'`, имя класса контроллера определяется как `Xyz`, а соответствующий класс - `protected/controllers/path/to/XyzController.php`. Например, идентификатор контроллера `admin.user` будет распознан так: класс контроллера - `UserController`, файл класса - `protected/controllers/admin/UserController.php`. Если файл класса не существует, будет сгенерирована ошибка 404 [CHttpException].


Экшн (Action)
-------------

Как было упомянуто выше, экшн - это метод, имя которого начинается на `action`. Более продвинутый путь - создать класс экшна и попросить контроллер создавать его экземпляр при необходимости. Такой подход позволяет повторно использовать экшны.

Для создания класса экшна необходимо следующее:

~~~
[php]
class UpdateAction extends CAction
{
	public function run()
	{
		// place the action logic here
	}
}
~~~

Чтобы осведомить контроллер об этом экшне, необходимо переопределить метод [actions()|CController::actions] в классе контроллера:

~~~
[php]
class PostController extends CController
{
	public function actions()
	{
		return array(
			'edit'=>'application.controllers.post.UpdateAction',
		);
	}
}
~~~

В приведенном коде мы используем псевдоним (alias) `application.controllers.post.UpdateAction` для указания на класс экшна `protected/controllers/post/UpdateAction.php`.

Создавая экшны, основанные на классах, можно огранизовать приложение в модульной манере. Так например, следующая структура директорий может
быть использована для расположения кода контроллеров:

~~~
protected/
    controllers/
        PostController.php
        UserController.php
        post/
            CreateAction.php
            ReadAction.php
            UpdateAction.php
        user/
            CreateAction.php
            ListAction.php
            ProfileAction.php
            UpdateAction.php
~~~

Фильтр (Filter)
---------------

Фильтр - это код который может выполняться перед или после экшна в зависимости от конфигурации.
Например, фильтр контроля доступа может проверять авторизирован ли пользователь перед тем, как будет выполнен экшн.
Фильтр, контролирующий производительность, может быть использован для определения времени, затраченного на выполнение экшна.

Экшн может иметь множество фильтров. Фильтры запускаются в том порядке, в котром они указаны в списке фильтров. Фильтр может
предотвратить выполнение следующих за ним фильтров.

Фильтр может быть определен как метод класса контроллера. Имя метода должно начинаться на `filter`. Например, существование метода
`filterAccessControl` означает, что определен фильтр `accessControl`. Метод фильра должен быть задан в форме:

~~~
[php]
public function filterAccessControl($filterChain)
{
	// call $filterChain->run() to continue filtering and action execution
}
~~~

где `$filterChain` - экземпляр [CFilterChain], представляющего собой список фильтров, ассоциированных с запрошенным экшном.
В коде фильтра можно вызвать `$filterChain->run()` для того, чтобы продолжить выполнение последующих фильтров и экшна.

Фильтр также может быть экземпляром класса [CFilter] или его производного. Следующий код определяет новый класс фильтра:

~~~
[php]
class PerformanceFilter extends CFilter
{
	protected function preFilter($filterChain)
	{
		// код, выполянемый перед запуском экшна
		return true; // false - в случае когда следует запретить выполнение экшна
	}

	protected function postFilter($filterChain)
	{
		// код, выполянемый после запуска экшна
	}
}
~~~

Для того, чтобы применить фильтр к экшну, необходимо переопределить метод `CController::filters()` method. 
Метод обязан вернуть массив конфигураций фильтров. Пример:

~~~
[php]
class PostController extends CController
{
	......
	public function filters()
	{
		return array(
			'postOnly + edit, create',
			array(
				'application.filters.PerformanceFilter - edit, create',
				'unit'=>'second',
			),
		);
	}
}
~~~

Данный код определяет два фильтра: `postOnly` и `PerformanceFilter`.
Фильтр `postOnly` задан методом (method-based) (соответствующий метод уже определен в [CController]), в то время как
`PerformanceFilter` - фильтр на базе класса (object-based). Псевдоним (alias) `application.filters.PerformanceFilter`
указывает, что класс фильтра - `protected/filters/PerformanceFilter`. Для конфигурации `PerformanceFilter` использован массив,
поэтому возможно инициализировать свойства фильтра. В данном случае свойство `unit` фильтра `PerformanceFilter` будет 
инициализировано значением `'second'`.

используя операторы `'+'` и `'-'` можно указать, к каким экшнам должен и не должен быть применен фильтр. В приведенном примере 
`postOnly` должен быть применен к экшнам `edit` и `create`, а `PerformanceFilter` - ко всем экшнам, КРОМЕ `edit` и `create`. 
Если операторы `'+'` и `'-'` не указаны - фильтр будет применен ко всем экшнам.

<div class="revision">$Id: basics.controller.txt 416 2008-12-28 05:28:11Z qiang.xue $</div>