Создание действия
=================

Когда готова модель, можно приступать к написанию кода для работы с ней. 
Всю логику обработки мы помещаем в действия контроллера. Для формы 
авторизации, например, нам потребуется следующий код:

~~~
[php]
public function actionLogin()
{
	$form=new LoginForm;
	if(isset($_POST['LoginForm']))
	{
		// получаем данные от пользователя
		$form->attributes=$_POST['LoginForm'];
		// проверяем полученные данные и, если результат проверки положительный,
		// перенаправляем пользователя на предыдущую страницу
		if($form->validate())
			$this->redirect(Yii::app()->user->returnUrl);
	}
	// рендерим представление — форму авторизации,
	// переменная $form в представлении будет представлена переменной с именем user
	$this->render('login',array('user'=>$form));
}
~~~

Вначале мы создаем экземпляр модели `LoginForm`, затем, если данные формы были 
отправлены, заполняем `$form` данными `$_POST['LoginForm']`. Потом проверяем 
полученные данные и, если все нормально, перенаправляем пользователя на страницу, 
для доступа к которой требовалось авторизоваться, т.е. ту страницу, которая 
отправила пользователя на страничку авторизации. Если же результат проверки 
отрицательный или действие выполняется впервые, то отображаем пользователю 
представление `login`, которое рассмотрим в следующем разделе.

> Tip|Подсказка: В действии `login` мы используем `Yii::app()->user->returnUrl`, 
чтобы получить URL страницы, которая затребовала авторизацию. Компонент `Yii::app()->user` 
является подклассом [CWebUser], который позволяет получить информацию, хранящуюся в сессии 
пользователя (например имя пользователя, статус и пр.). Подробно ознакомиться с темой можно 
в разделе [Аутентификация и авторизация](/doc/guide/topics.auth).

Обратим особое внимание на следующее выражение в действии `login`: 

~~~
[php]
$form->attributes=$_POST['LoginForm'];
~~~

Как мы уже говорили в подразделе [Безопасное присваивание значений атрибутам](/doc/guide/form.model#securing-attribute-assignments),
это выражение заполняет модель данными, которые вводит пользователь. Свойство `attributes` определяется 
классом [CModel], который ожидает получить массив пар имя-значение, чтобы затем присвоить каждому атрибуту модели 
соответствующее значение. Следовательно, если `$_POST['LoginForm']` содержит такой массив, то выражение, 
которое мы привели выше, будет эквивалентно следующему коду (считаем, что массив содержит все нужные нам атрибуты):

~~~
[php]
$form->username=$_POST['LoginForm']['username'];
$form->password=$_POST['LoginForm']['password'];
$form->rememberMe=$_POST['LoginForm']['rememberMe'];
~~~

> Note|Примечание: Для того, чтобы `$_POST['LoginForm']` вернул нам массив вместо строки, 
требуется следовать правилам именования полей ввода в представлении. Так поле, соответствующее 
атрибуту `a` в классе модели `C`, должно называться `C[a]`. В нашем примере для названия поля, соответствующего 
атрибуту `username`, мы будем использовать имя `LoginForm[username]`.

Теперь нам осталось только создать представление `login`, которое будет содержать
HTML форму с требуемыми полями.

<div class="revision">$Id: form.action.txt 626 2009-02-04 20:51:13Z qiang.xue $</div>