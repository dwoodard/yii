Кэширование фрагментов
================

Кэширование фрагментов относится к кэшированию фрагментов страницы. Например, 
если страница отображает суммарные годовые продажы в таблице, мы можем
сохранить эту таблицу в кэше с целью исключения времени, требуемого для
генерации таблицы при каждом запросе.

Для использования кэширования фрагментов мы вызываем 
[CController::beginCache()|CBaseController::beginCache()] и
[CController::endCache()|CBaseController::endCache()] в скрипте 
представления контроллера. Эти два метода являются метками начала и конца 
содержимого страницы, которое должно быть кэшировано. Как и в [кэшировании 
данных](/doc/guide/caching.data), нам нужен идентификатор (ID) для определения
кэшируемого фрагмента.

~~~
[php]
...некое HTML-содержимое...
<?php if($this->beginCache($id)) { ?>
...кэшируемое содержимое...
<?php $this->endCache(); } ?>
...другое HTML-содержимое...
~~~

В коде выше, если метод [beginCache()|CBaseController::beginCache()] возвращает
false, то кэшированное содержимое будет автоматически вставлено в данное место,
иначе, содержимое внутри выражения `if` будет выполнено и сохранено
в кэше, когда будет вызван метод [endCache()|CBaseController::endCache()].

Параметры кэширования
---------------

Вызывая метод [beginCache()|CBaseController::beginCache()], мы можем передать
в качестве второго параметра массив, содержащий параметры кэширования для
управления кэшированием фрагмента. Фактически, методы 
[beginCache()|CBaseController::beginCache()] и
[endCache()|CBaseController::endCache()] являются удобной оберткой 
виджета [COutputCache]. Поэтому, параметры кэширования могут быть 
начальными значениями для любых свойств виджета [COutputCache].

### Длительность (срок действия)

Наверное, наиболее часто используемым параметром является
[duration|COutputCache::duration],
который определяет, насколько долго содержимое кэша будет оставаться
действительным (валидным). Это похоже на параметр срока действия метода
[CCache::set()]. Код ниже кэширует фрагмент на время не более часа:

~~~
[php]
...другое HTML-содержимое...
<?php if($this->beginCache($id, array('duration'=>3600))) { ?>
...кэшируемое содержимое...
<?php $this->endCache(); } ?>
...другое HTML-содержимое...
~~~

Если мы не установим длительность, она будет равна 60 (значение по умолчанию).
Это значит, что кэшированное содержимое станет недействительным через 60
секунд.

### Зависимость

Как и [кэширование данных](/doc/guide/caching.data), кэшируемое содержимое
фрагмента тоже может иметь зависимости. Например, отображение содержимого
сообщения зависит от того, изменено или нет это сообщение.

Для определения зависимости, мы устанавливаем параметр
[dependency|COutputCache::dependency], который может быть либо объектом,
реализующим интерфейс [ICacheDependency], либо массивом настроек, который может
быть использован для генерации объекта зависимости. Следующий код 
определяет содержимое фрагмента, зависящее от изменения значения
столбца `lastModified`:

~~~
[php]
...другое HTML-содержимое...
<?php if($this->beginCache($id, array('dependency'=>array(
		'class'=>'system.caching.dependencies.CDbCacheDependency',
		'sql'=>'SELECT MAX(lastModified) FROM Post')))) { ?>
...кэшируемое содержимое...
<?php $this->endCache(); } ?>
...другое HTML-содержимое...
~~~

### Вариации (изменения)

Кэшируемое содержимое может быть изменено в соответствии с некоторыми
параметрами. Например, личный профиль может по-разному выглядеть для разных
пользователей. Для кэширования содержимого профиля мы мф хотели бы, чтобы
кэшированная копия была различной соответственно идентификатору пользователя.
По-существу, это значит, что мы должны использовать разные идентификаторы при
вызове метода [beginCache()|CBaseController::beginCache()].

Вместо того, чтобы спрашивать у разработчика различные идентификаторы, 
соответствующие некоторой схеме, существует класс [COutputCache], включающий в
себя такую возможность. Ниже приведен список встроенных вариаций.

   - [varyByRoute|COutputCache::varyByRoute]: если установлено в значение true,
кэшированное содержимое будет изменяться в соответствии с настройками в
[route](/doc/guide/basics.controller#route). Поэтому, каждая комбинация
запрашиваемого контроллера и действия будут иметь разное кэшированное
содержимое.

   - [varyBySession|COutputCache::varyBySession]: если установлено в значение
true, кэшированное содержимое будет изменяться в соответствии с
идентификатором сессии. Поэтому, каждая пользовательская сессия может видеть
различное содержимое и получать его из кэша.

   - [varyByParam|COutputCache::varyByParam]: если установлено в качестве 
массива имен, ames, кэшированное содержимое будет изменяться в соответствии с
определенными GET параметрами. Например, если страница отображает содержимое
сообщения в зависимости от GET-параметра `id`, мы можем определить 
[varyByParam|COutputCache::varyByParam] в виде массива `array('id')` и затем мы
можем кэшировать содержимое каждого сообщения. Без такой вариации, мы могли бы
кэшировать только одно сообщение.

### Типы запроса

Иногда мы хотим, чтобы кэширование фрагмента было включено только для некоторых
типов запроса. Например, страницу с формой мы хотим кэшировать только тогда,
когда она инициализирована (GET запросом) (не заполнена). Любое последующее
отображение формы (получившееся POST запросом) (заполненная форма) не должно
быть кэшировано, потому что может содержать данные, введенные пользователем.
Чтобы так сделать, мы определяем параметр
[requestTypes|COutputCache::requestTypes]:

~~~
[php]
...другое HTML содержмое...
<?php if($this->beginCache($id, array('requestTypes'=>array('GET')))) { ?>
...кэшируемое содержимое...
<?php $this->endCache(); } ?>
...другое HTML содержмое...
~~~

Вложенное кэширование
--------------

Кэширование врагментов может быть вложенным. Это значит, что кэшированный
фрагмент окружен более большим фрагментом, который тоже кэшируется. Например,
комментарии кэшированы во внутреннем фрагменте кэша, и они же кэшированы
вместе с содержимым сообщения во внешнем фрагменте кэша.

~~~
[php]
...другое HTML содержмое...
<?php if($this->beginCache($id1)) { ?>
...внешнее кэшируемое содержимое...
	<?php if($this->beginCache($id2)) { ?>
	...внутреннее кэшируемое содержимое...
	<?php $this->endCache(); } ?>
...внешнее кэшируемое содержимое...
<?php $this->endCache(); } ?>
...другое HTML содержмое...
~~~

Параметры кэширования могут быть различными для вложенных кэшей. Например,
внутренний и внешний кэши в вышеприведенном примере могут иметь разные
сроки действия. Когда кэшированные данные во внешнем кэше становятся
недействительны, внутренний кэш все еще может давать действительные фрагменты.
Тем не менее, это НЕ верно в обратном случае. Если внешний кэш содержит
действительные данные, он всегда будет давать кэшированную копию, даже если
у содержимого внутреннего кэша истек срок действия.

<div class="revision">$Id: caching.fragment.txt 323 2008-12-04 01:40:16Z qiang.xue $</div>