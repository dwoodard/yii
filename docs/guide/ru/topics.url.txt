Красивые адреса URL
===================

Управление URL-адресами в веб-приложениях включает в себя два аспекта. Во-первых,
приложению необходимо распарсить запрос пользователя, поступающий в виде URL, на удобоваримые параметры. 
Во-вторых, приложение должно предоставлять способ формирования адресов URL, с которыми оно сможет корректно работать.
В Yii-приложениях эти задачи решаются с использованием класса [CUrlManager].

Создание адресов URL
-------------

В принципе, адреса URL можно захардкодить прямо в представлениях контроллера, однако куда удобнее создавать их динамически:

~~~
[php]
$url=$this->createUrl($route,$params);
~~~

где `$this` относится к экземпляру контроллера; `$route` соответствует на [маршруту](/doc/guide/basics.controller#route) запроса, 
а `$params` является списком параметров `GET` для добавления к URL.

По умолчанию, адреса создаются посредством [createUrl|CController::createUrl] в `get`-формате. 
Например, при значения параметров `$route='post/read'` и `$params=array('id'=>100)`, получим такой URL:

~~~
/index.php?r=post/read&id=100
~~~

где параметры указаны в виде набора пар `имя=значение`, соединенных знаком `&`, а 
параметр `r` указывает на [маршрут](/doc/guide/basics.controller#route). Однако этот формат не шибко 
дружелюбен по отношению к пользователю.

Мы можем сделать так, чтобы адрес, приведенный в качестве примера выше, выглядел более аккуратно и понятно
за счет использования формата `path`, который  исключает использование 
строки запроса и включает все GET-параметры в информационную часть адреса URL:

~~~
/index.php/post/read/id/100
~~~

Для изменения формата представления адреса URL, нужно настроить компонент приложения [urlManager|CWebApplication::urlManager]
таким образом, чтобы метод [createUrl|CController::createUrl] мог автоматически переключиться на использование нового формата, а 
приложение могло корректно воспринимать новый формат адресов URL:

~~~
[php]
array(
	......
	'components'=>array(
		......
		'urlManager'=>array(
			'urlFormat'=>'path',
		),
	),
);
~~~

Обратите внимание, что указывать класс компонента [urlManager|CWebApplication::urlManager] не требуется, т.к. 
он уже объявлен как [CUrlManager] в [CWebApplication].

> Tip|Подсказка: Адрес URL, генерируемый методом [createUrl|CController::createUrl] является относительным. Для того, чтобы получить 
абсолютный адрес, нужно добавить префикс, используя `Yii::app()->hostInfo`, или вызвать метод 
[createAbsoluteUrl|CController::createAbsoluteUrl].

Человекопонятные URL
------------------

Если в качестве формата адреса URL используется `path`, то мы можем определить правила формирования URL, чтобы 
сделать адреса более привлекательными и понятными с точки зрения пользователя. Например, мы можем использовать 
короткий адрес `/post/100` вместо длинного варианта `/index.php/post/read/id/100`. [CUrlManager] использует правила формирования URL
как для создания, так и для обработки адресов.

Правила формирования URL задаются путем конфигурации свойства [rules|CUrlManager::rules] компонента приложения 
[urlManager|CWebApplication::urlManager]:

~~~
[php]
array(
	......
	'components'=>array(
		......
		'urlManager'=>array(
			'urlFormat'=>'path',
			'rules'=>array(
				'pattern1'=>'route1',
				'pattern2'=>'route2',
				'pattern3'=>'route3',
			),
		),
	),
);
~~~

Правила задаются в виде массива пар шаблон-путь, где каждая пара соответствует одному правилу.
Шаблон правила должен быть корректным регулярным выражением без разделителей и модификаторов. 
Он используется для поиска сооветствия информационной части пути URL. Шаблон [маршрута](/doc/guide/basics.controller#route)
должен соответствовать корректному маршруту контроллера.

Правило может быть ассоциировано с несколькими GET-параметрами. Эти параметры
указываются в шаблоне правила в виде маркеров следующим образом:

~~~
&lt;ParamName:ParamPattern&gt;
~~~

где `ParamName` соответствует имени GET-параметра, а опциональный `ParamPattern` соответствует 
регулярному выражению, которое используется для проверки соответствия значению GET-параметра.
В момент создания URL маркеры будут заменены на соответствующие значения параметров, а в момент обработки 
адреса URL соответствующие GET-параметрам будут присвоены результаты обработки.

Для наглядности приведем несколько примеров. Предположим, что наш набор правил состоит из трех правил:

~~~
[php]
array(
	'posts'=>'post/list',
	'post/<id:\d+>'=>'post/read',
	'post/<year:\d{4}>/<title>'=>'post/read',
)
~~~

   - Вызов `$this->createUrl('post/list')` сгенерирует `/index.php/posts`. Здесь было применено первое правило.

   - Вызов `$this->createUrl('post/read',array('id'=>100))` сгенерирует `/index.php/post/100`. Применено второе правило.
   
   - Вызов `$this->createUrl('post/read')` сгенерирует `/index.php/post/read`. Использовано третье правило.
   
При использовании [createUrl|CController::createUrl] для генерации адреса URL, маршрут и GET-параметры, переданные
методу, используются для определения правила, которое нужно применить. Правило применяется в том случае, когда все параметры, ассоциированные с правилом,
присутствуют среди GET-параметров, а маршрут соответствует параметру маршрута.

Если же количество GET-параметров больше, чем требует правило, то лишние параметры 
будут включены в строку запроса. Например, если вызвать `$this->createUrl('post/read',array('id'=>100,'year'=>2008))`,
мы получим `/index.php/post/100?year=2008`. Для того, чтобы  лишние параметры были отражены в информационной части пути, необходимо
добавить к правилу `/*`. Таким образом, используя правило `post/<id:\d+>/*` получим URL вида `/index.php/post/100/year/2008`.

Как уже говорилось, вторая задача правил URL - парсить URL-запросы. Этот процесс обратный процессу создания URL.
Например, когда пользователь запрашивает `/index.php/post/100`, применяется второе правило из примера выше и запрос 
преобразовывается в маршрут `post/read` и GET-параметр `array('id'=>100)` (доступный через `$_GET`).

> Note|Примечание: Использование правил URL снижает производительность приложения. Это происходит по той причине, что в процессе
парсинга запрошенного URL [CUrlManager] пытается найти соответствие каждому правилу до тех пор, пока какое-нибудь из правил не 
будет применено. Поэтому в случае высоконагруженных приложений использование правил URL стоит минимизировать.

### Скрываем `index.php`

С целью сделать адрес URL еще более привлекательным можно спрятать имя входного скрипта `index.php`. Для этого необходимо настроить
веб-сервер и компонент приложения [urlManager|CWebApplication::urlManager].

Вначале сконфигурируем веб-сервер таким образом, чтобы адрес URL без указания имени входного скрипта все также 
передавался на обработку входному скрипту. Для сервера [Apache HTTP server](http://httpd.apache.org/) это достигается 
путем включения движка преобразования адресов URL и настройки нескольких правил. И то, и другое можно сделать в файле 
`.htaccess`, размещенном в директории, содержащей входной скрипт. Например:

~~~
Options +FollowSymLinks
IndexIgnore */*
RewriteEngine on

# if a directory or a file exists, use it directly
RewriteCond %{REQUEST_FILENAME} !-f
RewriteCond %{REQUEST_FILENAME} !-d

# otherwise forward it to index.php
RewriteRule . index.php
~~~

Далее нужно установить свойство [showScriptName|CUrlManager::showScriptName] компонента 
[urlManager|CWebApplication::urlManager] равным `false`.

Теперь, вызвав `$this->createUrl('post/read',array('id'=>100))`, мы получим URL `/post/100`. Что важно, этот 
адрес URL будет корректно распознан нашим веб-приложением.

### Подмена окончания в адресе URL

В дополнение ко всему, перечисленному выше, мы можем добавить к нашим адресам URL окончание. Например,
мы можем получить `/post/100.html` вместо `/post/100`, представив пользователю как будто бы статичную страничку.
Для этого нужно просто настроить компонент [urlManager|CWebApplication::urlManager] путем назначения свойству 
[urlSuffix|CUrlManager::urlSuffix] любого желаемого окончания.

<div class="revision">$Id: topics.url.txt 229 2008-11-16 21:14:59Z qiang.xue $</div>