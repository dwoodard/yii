Компонент (Component)
=====================

Yii-приложения состоят из компонентов - объектов, созданых согласно спецификациям.
Компонент - это экземпляр класса [CComponent] или производного от него. Использование компонента
в основном включает доступ к его свойствам, а также вызов и обработку его событий. Базовый класс
[CComponent] устанавливает то, как определяются свойства и события.
Вообще говоря, практически все классы наследованы от класса [CComponent] 
(прим. перев.)

Свойство компонента
-------------------

Свойство компонента схоже с общими переменным-членами класса (public member variable). Мы можем читать или
устанавливать его значение. Например,

~~~
[php]
$width=$component->textWidth;     // получаем значение свойства textWidth
$component->enableCaching=true;   // устанавливаем значение свойства enableCaching
~~~

Для того, чтобы создать свойство компонента необходимо просто объявить общее поле в классе компонента.
Более гибкий путь - это определить методы, считывающие (getter) и устанавливающие (setter) это 
свойство, например:

~~~
[php]
public function getTextWidth()
{
    return $this->_textWidth;
}

public function setTextWidth($value)
{
    $this->_textWidth=$value;
}
~~~

В приведенном коде определено свойство `textWidth` (имя нечувствительно к регистру), доступное для записи.
При чтении вызывается метод-геттер `getTextWidth()`, возвращая значение свойства. Соответственно, при записи
будет вызван метод-сеттер `setTextWidth()`. Если сеттер не определен, свойство будет доступно только для чтения, а
при попытке записи будет сгенерировано исключение. Использование геттера и сеттера имеет дополнительное 
преимущество - при чтении или записи значения свойства могут быть произведены дополнительные действия (такие как валидация, 
вызов события и др.).

>Note: Есть небольшая разница в определении свойства через методы и через простое
объявление переменной. В первом случае имя свойства нечувствительно к регистру, 
во втором - чуствительно.

>Note: (от переводчика) При работе со свойствами компонента, описанные через методы,
надо помнить о том, что фактически это вызовы методов, поэтому PHP-функции `empty()`,
`isset()` и аналогичные к ним неприменимы.

События компонента
------------------

События компонента - это специальные свойства, значениями которых должны быть
методы (называемые обработчиками событий), как значения.
Прикрепление (присвоение) метода событию приведет к тому, что метод будет вызван 
автоматически при возникновении события. Поэтому поведение компонента может быть 
изменено так, как даже и не предполагалось при его разработке.

Событие компонента задается путем создания метода с именем, начинающимя на `on`. 
Подобно именам свойств, заданных через методы чтения/записи, имя события 
не чувствительно к регистру. Следующий код задает событие `onClicked`:

~~~
[php]
public function onClicked($event)
{
	$this->raiseEvent('onClicked', $event);
}
~~~

где `$event` - это экземпляр класса [CEvent] или производного от него, 
представляющего параметр события.

Можно подключить обработчик к событию как показано ниже:

~~~
[php]
$component->onClicked=$callback;
~~~

где `$callback` - это корректный callback-вызов PHP (см. PHP-функцию call_user_func).
Это может быть либо глобальная функция, либо метод объекта, либо статический метод класса.
Если это функция - то должна передаваться строка с ее именем. Если метод объекта, то массив
`array($object,'methodName')`. Если же статический метод класса - то массив 
`array('ClassName','methodName')`.

Обработчик события должен быть определен следующим образом:

~~~
[php]
function methodName($event)
{
    ......
}
~~~

где `$event` - это параметр, описывающий событие (происходит из вызова `raiseEvent()`). 
Параметр `$event` - это экземпляр класса [CEvent] или его производного. Как минимум, он содержит информацию о том,
кто вызвал событие.

Если теперь вызвать `onClicked()`, событие `onClicked` будет вызвано (внутри `onClicked()`), и прикрепленный обработчик
события будет запущен автоматически.

К событию может быть прикреплено несколько обработчиков. При возникновении события обработчики будут вызваны в том порядке,
в котором они были прикреплены к событию. Если в обработчике необходимо предотвратить вызов последующих обработчиков, 
необходимо установить [$event->handled|CEvent::handled] в `true`.

<div class="revision">$Id: basics.component.txt 416 2008-12-28 05:28:11Z qiang.xue $</div>