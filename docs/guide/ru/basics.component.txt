Компонент (Component)
=====================

Yii-приложения состоят из компонентов - объектов, созданых согласно спецификациям.
Компонент - это экземпляр класса [CComponent] или производного от него. Использование компонента
в основном включает доступ к его свойствам, а также вызов и обработку его событий. Базовый класс
[CComponent] устанавливает то, как определяются свойства и события.

Свойство компонента
-------------------

Свойство компонента схоже с общим полем класса (public member variable). Мы можем читать или
устанавливать его значение. К примеру,

~~~
[php]
$width=$component->textWidth;     // получаем значение свойства textWidth
$component->enableCaching=true;   // устанавливаем значение свойства enableCaching
~~~

Для того, чтобы создать свойство компонента необходимо просто объявить общее поле в классе компонента.
Более гибкий путь - задать геттер и сеттер (getter and setter methods), например так:

~~~
[php]
public function getTextWidth()
{
    return $this->_textWidth;
}

public function setTextWidth($value)
{
    $this->_textWidth=$value;
}
~~~

В приведенном коде определено свойство `textWidth` (имя регистронезависимо), доступное для записи.
При чтении вызывается метод-геттер `getTextWidth()`, возвращая значение свойства. Соответственно, при записи
будет вызван метод-сеттер `setTextWidth()`. Если сеттер не определен, свойство будет доступно только для чтения, а
при попытке записи будет сгенерировано исключение. Использование геттера и сеттера имеет дополнительное 
преимущество - при чтении или записи значения свойства могут быть произведены дополнительные действия (такие как валидация, 
вызов события и др.).

>Note: Есть небольшое отличие между свойством, определенным с помощью геттера/сеттера и свойством, заданным как общее поле класса.
В первом случае - имя свойства регистронезависимо, а во втором - зависимо.

События компонента
------------------

События компонента - это специальные свойства, принимающие методы (называемые обработчиками событий), как значения.
Прикрепление (присвоение) метода событию приведет к тому, что метод будет вызван автоматически при возникновении события.
Поэтому поведение компонента может быть изменено так, как даже и не предполагалось при его разработке.

Событие компонента задается путем создания метода с именем, начинающимя на `on`. 
Подобно именам свойств, заданных с помощью геттера/сеттера, имя события регистронезависимо.
Следующий код задает событие `onClicked`:

~~~
[php]
public function onClicked($event)
{
	$this->raiseEvent('onClicked', $event);
}
~~~

где `$event` - это экземпляр класса [CEvent] или производного, представляющий параметр события.

Можно прикрепить метод к событию как показано ниже:

~~~
[php]
$component->onClicked=$callback;
~~~

где `$callback` указывает на существующую PHP-функцию (valid PHP callback). Это может быть глобальная 
функция или метод класса. В последнем случае следует использовать форму `array($object,'methodName')`.

Обработчик события должен быть задан следующим образом:

~~~
[php]
function methodName($event)
{
    ......
}
~~~

где `$event` - это параметр, описывающий событие (происходит из вызова `raiseEvent()`). 
Параметр `$event` - это экземпляр класса [CEvent] или его производного. Как минимум, он содержит информацию о том,
кто вызвал событие.

Если теперь вызвать `onClicked()`, событие `onClicked` будет вызвано (внутри `onClicked()`), и прикрепленный обработчик
события будет запущен автоматически.

К событию может быть прикреплено несколько обработчиков. При возникновении события обработчики будут вызваны в том порядке,
в котором они были прикреплены к событию. Если в обработчике необходимо предотвратить вызов последующих обработчиков, 
необходимо установить [$event->handled|CEvent::handled] в true.

<div class="revision">$Id: basics.component.txt 416 2008-12-28 05:28:11Z qiang.xue $</div>