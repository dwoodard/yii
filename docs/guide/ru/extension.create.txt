Создание расширений

Так как расширение может быть использовано сторонними разработчиками, при его создании имеются дополнительные требования:
Расширение должно быть самодостаточным. Это значит, что его внешние зависимости должны быть минимальными. Для пользователей может стать серьёзной проблемой то, что расширение требует установку дополнительных пакетов, классов или исходных файлов.
Файлы, принадлежащие расширению, должны быть собраны в одной директории, чье имя является названием расширения.
Классы в расширении должны иметь приставки в названии, чтобы избежать конфликт с классами в других расширениях.
Расширение должно идти с подробным руководством по установке и с API документацией. Это поможет сократить время и усилия, затрачиваемые для использования расширения сторонними разработчиками.
Расширение должно использовать надлежащую лицензию. Если вы хотите создать расширение, которое могут использовать как открытые, так и закрытые проекты, то вы можете использовать такие лицензии, как BSD, MIT и так далее, но вы не можете использовать GPL, так как она заявляет, что разрабатываемый код должен быть открытым.
Далее мы вам расскажем, как создать новое расширение в соответствии с классификацией, описанной в обзоре. Это описание поможет вам, если вы хотите создать свой собственный компонент, используемый только в вашем проекте.
(Aplication Component)Компонент приложения
Компонент приложения должен использовать интерфейс IApplicationComponent или наследовать CApplicationComponent. Основной метод, который нужно реализовать из IApplicationComponent, это IApplicationComponent::init(), в котором выполняются некоторые действия по инициализации. Этот метод выполняется после создания компоненты и исходные значения свойств(указзыаные в конфигурации приложения) переданны.

По умолчанию компонента приложения создается и инициализируется только тогда, когда вызывается первый раз вовремя обработки запроса. Если создания компоненты требуется еще раз после того как сущность приложения была создана, от пользователя потребуется идентификатор в свойство CApplication::preload. 

Widget(Виджет)

Виджет должен наследовать CWidget или его потомков.
Просто способ написания виджета это наследование существующего виджета и переписывание его методов или изменения значения свойств по умолчанию. К примеру, если вы хотите использовать более красивый CSS стиль для CTabView, вы можете настроить его в свойстве CTabView::cssFile, когда используете виджет. Также вы можете наследовать CTabView как показано ниже, и вам больше не нужно будеть настраивать свойство, когда вы используете виджет.
class MyTabView extends CTabView
{
	public function init()
	{
		if($this->cssFile===null)
		{
			$file=dirname( FILE ).DIRECTORY SEPARATOR.’tabview.css’;
			$this->cssFile=Yii::app()->getAssetManager()->publish($file);
		}
		parent::init();
	}
}
В приведенном выше примере, мы переписали метод CWidget::init() и указали в CWidget::cssFile по ссылке к нашему новому CSS стилю по умолчанию, если он не указан. Мы положим новый CSS файл в туже директорию, что и содержит виджет MyTabView, и по этому она может быть использованна как расширение. Так как файл к css-стилем не доступен через веб,нам необходимо выпустить его в актив.

Для созадния виджета с нуля, нам необходимо применить два метода: CWidget::init() and CWidget::run(). Вызывается когда мы используем $this->beginWidget для вставки виджета в представление, и второй метод вызывается когда, используется $this->endWidget. Если мы хотим управлять отображающимся контентом между вызовами двух методов, мы можем начать буферизацию вывода в CWidget::init() и получить буферизованный вывод в CWidget::run() для следующей обработки.

Виджет часто предпологает включение CSS, JavaScript и других файловых ресурсов на странице, в которой используется виджет. Мы называем такие файлы assets(активами) потому что они поставляются вместе с классом виджета и обычно не доступны для веб-пользователей. В следствии того, что нужно сделать их веб доступными, мы должны опубликовать их, используя CWebApplication::assetMenager, как показано, на ниже приведенном, участке кода. Кроме того если мы хотим включить CSS или JavaScript на текущей странице, мы должны зарегистрировать их, используя CClientScript.

class MyWidget extends CWidget
{
	protected function registerClientScript()
	{
		// ...publish CSS or JavaScript file here...
		$cs=Yii::app()->clientScript;
		$cs->registerCssFile($cssFile);
		$cs->registerScriptFile($jsFile);
	}
}

Виджет может иметь свои собственные файлы представления. Если так, то создайте директорию называемую «views» в директории содержащей файл с классом виджета, и положите все файлы представления туда. В классе виджета, следует от рендерить обзор, используя  $this->render(’ViewName’), который аналогичен тому, что мы делаем в контроллере.

Action(действие)
 
Действие должно наследывать класс CAction или его потомков. Основной метод, который должен быть реализован в действии это IAction::run. 
Filter(фильтр)
Фильтр должен наследывать класс Cfilter или его детей. Основные методы, которые нужно реализовать для фильтра это  CFilter::preFilter и CFilter::postFilter. Первый вызывается до совершение действия, когда второй выполняется после.

class MyFilter extends CFilter
{
	protected function preFilter($filterChain)
	{
		// logic being applied before the action is executed	
		return true; // false if the action should not be executed
	}
	protected function postFilter($filterChain)
	{
		// logic being applied after the action is executed
	}
}

Параметр $fileterChain является обьектом типа CfilterChain, который содержит информацию о действие, которое сейчас фильтрируется.

Контроллер(Controller)
Контроллер, поставляющийся как расширение, должен наследовать CExtendController, вместо CController. Основная причина этого то, что CController предполагает, что файлы принадлежащие представлению контроллера расположены в  application.views.ControllerID, тогда как  CextendController предпологают что файлы представления лежат в директории «views», которая является поддиректорией директории, содержащей файл с классом контроллером. Темболее, это проще для распространения контроллера, так как все его представления остаются вместе с файлом класса контроллера.


Validator(Валидатор)
Валидатор должен наследоваться от CValidator и должен осуществить его CValidator::validateAttribute метод.
class MyValidator extends CValidator
{
	protected function validateAttribute($model,$attribute)
	{	
		$value=$model->$attribute;
		if($value has error)
		$model->addError($attribute,$errorMessage);
	}
}

Console Command(Команда консоли)
Комманда консоли наследует класс CconsoleCommand и реализовать метод на CСonsoleCommand::run. Опционально вы можете переписать CconsoleCommand::getHelp() для предоставления некоторой информации о команде.

class MyCommand extends CConsoleCommand
{
	public function run($args)
	{
		// $args gives an array of the command-line arguments for this command
	}
	public function getHelp()
	{	
		return ’Usage: how to use this command’;
	}	
}

Module(Модуль)
При разработки модуль нужно руководствоваться тем, что он должен быть само достаточным. Файлы ресурсов(CSS,JavaScript,картинки), которые использует модуль, должны поставляться с модулем. И модуль должен предоставлять их так, что бы они были веб-доступными.

Типовой компонент 
Разработка типового компонента это как написание класса. Опять же компонент, должен быть само достаточным, что бы он мог легко использоваться другими разработчиками.

<div class="revision">$Id: extension.create.txt 273 2008-11-25 03:11:45Z qiang.xue $</div>