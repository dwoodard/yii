Data Caching
============

Data caching is about storing some PHP variable in cache and retrieving it
later from cache. For this purpose, the cache component base class [CCache]
provides two methods that are used most of the time: [set()|CCache::set]
and [get()|CCache::get].

To store a variable `$value` in cache, we choose a unique ID and call
[set()|CCache::set] to store it:

~~~
[php]
Yii::app()->cache->set($id, $value);
~~~

The cached data will remain in the cache forever unless it is removed
because of some caching policy (e.g. caching space is full and the oldest
data are removed). To change this behavior, we can also supply an
expiration parameter when calling [set()|CCache::set] so that the data will
be removed from the cache after a certain period of time:

~~~
[php]
// keep the value in cache for at most 30 seconds
Yii::app()->cache->set($id, $value, 30);
~~~

Later when we need to access this variable (in either the same or a
different Web request), we call [get()|CCache::get] with the ID to retrieve
it from cache. If the value returned is false, it means the value is not
available in cache and we should regenerate it.

~~~
[php]
$value=Yii::app()->cache->get($id);
if($value===false)
{
	// regenerate $value because it is not found in cache
	// and save it in cache for later use:
	// Yii::app()->cache->set($id,$value);
}
~~~

When choosing the ID for a variable to be cached, make sure the ID is
unique among all other variables that may be cached in the application. It
is NOT required that the ID is unique across applications because the cache
component is intelligent enough to differentiate IDs for different
applications.

Some cache storages, such as MemCache, APC, support retrieving
multiple cached values in a batch mode, which may reduce the overhead involved
in retrieving cached data. A method named
[mget()|CCache::mget] is provided to exploit this feature. In case the underlying
cache storage does not support this feature, [mget()|CCache::mget] will still
simulate it.

To remove a cached value from cache, call [delete()|CCache::delete]; and
to remove everything from cache, call [flush()|CCache::flush]. Be very
careful when calling [flush()|CCache::flush] because it also removes cached
data that are from other applications.

> Tip: Because [CCache] implements `ArrayAccess`, a cache component can be
> used liked an array. The followings are some examples:
> ~~~
> [php]
> $cache=Yii::app()->cache;
> $cache['var1']=$value1;  // equivalent to: $cache->set('var1',$value1);
> $value2=$cache['var2'];  // equivalent to: $value2=$cache->get('var2');
> ~~~

Cache Dependency
----------------

Besides expiration setting, cached data may also be invalidated according
to some dependency changes. For example, if we are caching the content of
some file and the file is changed, we should invalidate the cached copy and
read the latest content from the file instead of the cache.

We represent a dependency as an instance of [CCacheDependency] or its
child class. We pass the dependency instance along with the data to be
cached when calling [set()|CCache::set].

~~~
[php]
// the value will expire in 30 seconds
// it may also be invalidated earlier if the dependent file is changed
Yii::app()->cache->set($id, $value, 30, new CFileCacheDependency('FileName'));
~~~

Now if we retrieve `$value` from cache by calling [get()|CCache::get], the
dependency will be evaluated and if it is changed, we will get a false
value, indicating the data needs to be regenerated.

Below is a summary of the available cache dependencies:

   - [CFileCacheDependency]: the dependency is changed if the file's last
modification time is changed.

   - [CDirectoryCacheDependency]: the dependency is changed if any of the
files under the directory and its subdirectories is changed.

   - [CDbCacheDependency]: the dependency is changed if the query result
of the specified SQL statement is changed.

   - [CGlobalStateCacheDependency]: the dependency is changed if the value
of the specified global state is changed. A global state is a variable that
is persistent across multiple requests and multiple sessions in an
application. It is defined via [CApplication::setGlobalState()].

   - [CChainedCacheDependency]: the dependency is changed if any of the
dependencies on the chain is changed.

   - [CExpressionDependency]: the dependency is changed if the result of
the specified PHP expression is changed.


Query Caching
-------------

Since version 1.1.7, Yii has added support for query caching.
Built on top of data caching, query caching stores the result of a DB query
in cache and may thus save the DB query execution time if the same query is requested
in future, as the result can be directly served from the cache.

> Info: Some DBMS (e.g. [MySQL](http://dev.mysql.com/doc/refman/5.1/en/query-cache.html))
> also support query caching on the DB server side. Compared with the server-side
> query caching, the same feature we support here offers more flexibility and
> potentially may be more efficient.


### Query Caching with DAO

To use query caching, we call the [CDbConnection::cache()] method when we perform DB queries.
The following is an example:

~~~
[php]
$sql = 'SELECT * FROM tbl_post LIMIT 20';
$rows = Yii::app()->db->cache(1000)->createCommand($sql)->queryAll();
~~~

Here we specify that the query results should remain valid in cache for 1000 seconds.
If we execute the same lines of code within the next 100 seconds again, the query results
will be fetched from cache without actually executing the SQL statement.

We can also specify a cache dependency for the query result we are caching. For example,
if there are any changes to the `tbl_post` table, then we should invalidate the cached
query results.

~~~
[php]
$sql = 'SELECT * FROM tbl_post LIMIT 20';
$dependency = new CDbCacheDependency('SELECT MAX(update_time) FROM tbl_post');
$rows = Yii::app()->db->cache(1000, $dependency)->createCommand($sql)->queryAll();
~~~

In the above code, we create a dependency which checks the maximum `update_time` of all records
in the table. If the value has any change, it means the table data is changed and we should
invalidate the query cache.


### Query Caching with ActiveRecord

Query caching can also be used with [Active Record](/doc/guide/database.ar).
To do so, we call a similar [CActiveRecord::cache()] method like the following:

~~~
[php]
$posts = Post::model()->cache(1000)->findAll();
~~~

It also works with [Relational Active Record](/doc/guide/database.arr). For example,

~~~
[php]
$posts = Post::model()->cache(1000)->with('author')->findAll();
~~~

By default, each time we call the `cache()` method (of either [CDbConnection] or [CActiveRecord]),
it will mark the next SQL query to be cached. Any other SQL queries will NOT be cached
unless we call `cache()` again.

As we know, when doing a single relational AR query, it is possible several SQL queries will
be performed. For example, if the relationship between `post` and `comments` is `HAS_MANY`,
then the following code will actually execute two DB queries: it first selects the posts limited by 20,
and then selects the comments for the previously selected posts.

~~~
[php]
$posts = Post::model()->with('comments')->findAll(array(
	'limit'=>20,
));
~~~

If we use query caching as follows, only the first DB query will be cached:

~~~
[php]
$posts = Post::model()->cache(1000)->with('comments')->findAll(array(
	'limit'=>20,
));
~~~

In order to cache both DB queries, we can supply an extra parameter indicating how
many DB queries we want to cache next:

~~~
[php]
$posts = Post::model()->cache(1000, null, 2)->with('comments')->findAll(array(
	'limit'=>20,
));
~~~


### Configuring Query Caching

To configure query caching, we can set the relevant properties of [CDbConnection].

By default, query results are cached in a cache application component named `cache`.
We can change this by modifying the property [CDbConnection::queryCacheID].
If we set this property to be false, then query caching will be disabled completely.

We can also configure [CDbConnection::queryCachingDuration], [CDbConnection::queryCachingDependency]
and [CDbConnection::queryCachingCount]. However, these properties are more often
configured by calling [CDbConnection::cache()] or [CActiveRecord::cache()], as we
have shown in the above.



<div class="revision">$Id$</div>