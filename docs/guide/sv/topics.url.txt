URL-hantering
=============

Komplett URL-hantering för en webbapplikation involverar två aspekter. För det 
första, när en användar-request kommer in i form av en URL, behöver 
applikationen avkoda den till begripliga parametrar. För det andra behöver 
applikationen erbjuda ett sätt att skapa URL:er på ett sådant vis att de är 
begripliga för applikationen. En Yii-applikation åstadkommer detta med hjälp av 
[CUrlManager].

Skapa URL:er
------------

Även om URL:er kan hårdkodas i kontrollervyer, är det ofta mer flexibelt att 
skapa dem dynamiskt:

~~~
[php]
$url=$this->createUrl($route,$params);
~~~

där `$this` refererar till kontrollerinstansen; `$route` anger 
[route](/doc/guide/basics.controller#route) för önskad request; `$params` är en 
lista med `GET`-parametrar som skall läggas till URL:en.

Som standard är URL:er som skapats med hjälp av 
[createUrl|CController::createUrl] av det så kallade `get`-formatet. Till 
exempel, givet `$route='post/read'` och `$params=array('id'=>100)`, skulle vi 
erhålla följande URL:

~~~
/index.php?r=post/read&id=100
~~~

där parametrarna återfinns i frågesträngen sammanslagna till en lista av 
`Namn=Värde`-par separerade av och-tecken (&), och där `r`-parametern 
specificerar request-[route](/doc/guide/basics.controller#route). Detta 
URL-format är inte speciellt användarvänligt eftersom det erfordrar ett antal 
ordfrämmande tecken.

Ovanstående URL kan fås att se renare ut samt mer självförklarande genom 
användning av det så kallade `path`-formatet, vilket eliminerar frågesträngen 
och dessutom placerar GET-parametrarna i den del av URL:en som innehåller path-info:

~~~
/index.php/post/read/id/100
~~~

För att byta URL:format konfigurerar vi applikationskomponenten 
[urlManager|CWebApplication::urlManager] så att 
[createUrl|CController::createUrl] automatiskt kan byta till det nya formatet 
och så att applikationen korrekt kan begripa de nya URL:erna:

~~~
[php]
array(
	......
	'components'=>array(
		......
		'urlManager'=>array(
			'urlFormat'=>'path',
		),
	),
);
~~~

Lägg märke till att vi inte behöver klass för komponenten 
[urlManager|CWebApplication::urlManager], den är fördeklarerad som [CUrlManager] 
i [CWebApplication].

> Tip|Tips: URL:en som genereras av metoden [createUrl|CController::createUrl] 
är en relativ sådan. För att få en absolut URL kan vi infoga ett prefix med 
hjälp av `Yii::app()->hostInfo`, alternativt anropa 
[createAbsoluteUrl|CController::createAbsoluteUrl].

Användarvänliga URL:er
----------------------

När `path` används dom URL-format kan vi specificera vissa URL-regler för att 
göra våra URL:er ännu mer användarvänliga. Vi kan till exempel generera en så 
kort URL som `/post/100`, i stället för det betydligt längre 
`/index.php/post/read/id/100`. URL-regler används av [CUrlManager] både för att 
skapa URL:er och för URL-parsning.

För att ange URL-regler behöver vi konfigurera propertyn 
[rules|CUrlManager::rules]  i applikationskomponenten 
[urlManager|CWebApplication::urlManager]:

~~~
[php]
array(
	......
	'components'=>array(
		......
		'urlManager'=>array(
			'urlFormat'=>'path',
			'rules'=>array(
				'pattern1'=>'route1',
				'pattern2'=>'route2',
				'pattern3'=>'route3',
			),
		),
	),
);
~~~

Reglerna specificeras i form av en array av mönster-routepar, vart och ett 
motsvarande en enstaka regel. Mönstret i en regel måste vara ett giltigt 
reguljärt uttryck (regexp) utan avgränsare och modifierare. Det används till att 
matcha pathinfo-delen av URL:erna. [route](/doc/guide/basics.controller#route) 
skall referera till en giltig kontrollerroute.

En regel kan associeras med några GET-parametrar. Dessa GET-parametrar upprtäder 
i regelns mönster som speciella symboler på följande format:

~~~
&lt;ParamName:ParamPattern&gt;
~~~

där `ParamName` specificerar namnet på en GET-parameter och det frivilliga 
`ParamPattern` specificerar det reguljära uttrycket som skall användas för att 
matcha GET-parameterns värde. När en URL skapas kommer dessa parametersymboler 
att ersättas med motsvarande parametervärden; vid parsning av en URL, kommer de 
motsvarande GET-parametrarna att erhålla värden från resultatet av parsningen.

Några exempel följer nu för att belysa hur URL-regler fungerar. 
Regeluppsättningen antas innehålla tre regler:

~~~
[php]
array(
	'posts'=>'post/list',
	'post/<id:\d+>'=>'post/read',
	'post/<year:\d{4}>/<title>'=>'post/read',
)
~~~

   - Anropet `$this->createUrl('post/list')` genererar `/index.php/posts`. Den 
   första regeln appliceras.

   - Anropet `$this->createUrl('post/read',array('id'=>100))` genererar 
   `/index.php/post/100`. Den andra regeln appliceras.

   - Anropet `$this->createUrl('post/read',array('year'=>2008,'title'=>'a sample 
   post'))` genererar `/index.php/post/2008/a%20sample%20post`. Den tredje 
   regeln appliceras.

   - Anropet `$this->createUrl('post/read')` genererar `/index.php/post/read`. 
   Ingen av reglerna appliceras.

Sammanfattningsvis, när [createUrl|CController::createUrl] används för att 
generera en URL, används route- och GET-parametrarnas som lämnas till funktionen 
till att avgöra vilken URL-regel som skall appliceras. Om varje parameter 
associerad med en regel kan hittas bland GET-parametrarna som lämnats till 
[createUrl|CController::createUrl], och om regelns route också matchar 
routeparametern, kommer regeln att användas för att generera URL:en.

Om GET-parametrarna som lämnas till [createUrl|CController::createUrl] är fler 
än de som behövs i en regel, hamnar de överflödiga parametrarna i en query-
sträng. Till exempel, ur anropet `$this->createUrl('post/read',array('id'=>100,'year'=>2008))`, 
erhålls `/index.php/post/100?year=2008`. För att få dessa tillkommande parametrar att 
hamna i pathinfo-delen, kompletterar vi regeln med `/*`. Med regeln 
`post/<id:\d+>/*` erhåller vi URL:en `/index.php/post/100/year/2008`.

Som nämnts är det andra ändamålet med URL-regler parsning av request-URL:er. 
Detta är naturligtvis den omvända processen mot URL-generering. Till exempel, 
när en användare skickar en request `/index.php/post/100`, kommer den andra 
regeln i ovanstående exempel att appliceras, vilket löses upp till en route 
`post/read` och GET-parametern `array('id'=>100)` (kan nås  via `$_GET`).

> Note|Märk: Användning av URL-regler försämrar applikationen prestanda. Detta 
beror på att vid parsning av request-URL:en, kommer [CUrlManager] att försöka 
matcha den mot varje regel tills någon kan appliceras. Av denna anledning skall 
en webbapplikation med intensiv trafik minimera sin användning av URL-regler.

### Gömma `index.php`

Det finns en sak till att göra för att ytterligare rensa upp URL:er, att 
eliminera startskriptet `index.php` från URL:en. Detta kräver att vi 
konfigurerar webbservern såväl som applikationskomponenten 
[urlManager|CWebApplication::urlManager].

Webbservern behöver konfigureras så att URL:en utan startskriptdelen fortfarande 
kommer att hanteras av startskriptet. För [Apache HTTP-server](http://httpd.apache.org/), 
kan detta åstadkommas genom att slå på URL rewriting engine och 
specificera några rewriting-regler. Båda dessa saker 
kan härbärgeras i en `.htaccess`-fil placerad i katalogen som innehåller 
startkriptet. Följande är ett exempel:

~~~
Options +FollowSymLinks
IndexIgnore */*
RewriteEngine on

# if a directory or a file exists, use it directly
RewriteCond %{REQUEST_FILENAME} !-f
RewriteCond %{REQUEST_FILENAME} !-d

# otherwise forward it to index.php
RewriteRule . index.php
~~~

Därefter konfigurerar vi propertyn [showScriptName|CUrlManager::showScriptName] 
i komponenten [urlManager|CWebApplication::urlManager] till `false`.

Med anropet `$this->createUrl('post/read',array('id'=>100))`, erhålls nu URL:en 
`/post/100`. Och nog så viktigt, denna URL kan kännas igen korrekt av 
webbapplikationen.

### Låtsat URL-suffix

Vi kan även lägga till något suffix till URL:er. Till exempel, kan vi erhålla 
`/post/100.html` i stället för `/post/100`. Detta liknar mer en URL till en 
statisk webbsida. För att göra så, konfigurera komponenten 
[urlManager|CWebApplication::urlManager] genom att sätta dess property 
[urlSuffix|CUrlManager::urlSuffix] till önskad suffixsträng.

<div class="revision">$Id: topics.url.txt 229 2008-11-16 21:14:59Z qiang.xue $</div>