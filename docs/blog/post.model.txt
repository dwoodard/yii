Customizing Post Model
======================

The `Post` model class generated by the `yiic` tool mainly needs to be modified in two places:

 - the `rules()` method: specifies the validation rules for the model attributes;
 - the `relations()` method: specifies the related objects;

> Info: A [model](http://www.yiiframework.com/doc/guide/basics.model) consists of a list of attributes, each associated with a column in the corresponding database table. Attributes can be declared explicitly as class member variables or implicitly without any declaration.

Please note, if you are using Yii version 1.0.x, then you will also need to customize the `safeAttributes()` method, which declares the list of attributes whose values can be massively populated from user inputs. Since version 1.1.0, this is no longer needed as a safe attribute is defined to be an attribute associated with a validation rule declared in `rules()`.


Customizing `rules()` Method
----------------------------

We first specify the validation rules which ensure the attribute values populated by user inputs are correct before they are saved to the database. For example, the `status` attribute of `Post` should be an integer 0, 1 or 2. The `yiic` tool also generates validation rules for each model. However, these rules are based on the table column information and may not be appropriate.

Based on the requirements analysis, we modify the `rules()` method as follows:

~~~
[php]
public function rules()
{
	return array(
		array('title, content, status', 'required'),
		array('title', 'length', 'max'=>128),
		array('status', 'in', 'range'=>array(0, 1, 2)),
		array('tags', 'match', 'pattern'=>'/^[\w\s,]+$/',
			'message'=>'Tags can only contain word characters.'),
	);
}
~~~

In the above, we specify that the `title`, `content` and `status` attributes are required; the length of `title` should not exceed 128; the `status` attribute value should be 0 (draft), 1 (published) or 2 (archived); and the `tags` attribute should only contain word characters and commas. All other attributes (e.g. `id`, `createTime`) will not be validated because their values do not come from user input.

After making these changes, we can visit the post creation page again to verify that the new validation rules are taking effect.

> Info: Validation rules are used when we call the [validate()|CModel::validate] or [save()|CActiveRecord::save] method of the model instance. For more information about how to specify validation rules, please refer to [the Guide](http://www.yiiframework.com/doc/guide/form.model#declaring-validation-rules).

Customizing `relations()` Method
--------------------------------

Lastly we customize the `relations()` method to specify the related objects of a post. By declaring these related objects in `relations()`, we can exploit the powerful [Relational ActiveRecord (RAR)](http://www.yiiframework.com/doc/guide/database.arr) feature to access the related object information of a post, such as its author and comments, without the need to write complex SQL JOIN statements.

We customize the `relations()` method as follows:

~~~
[php]
public function relations()
{
	return array(
		'author'=>array(self::BELONGS_TO, 'User', 'authorId'),
		'comments'=>array(self::HAS_MANY, 'Comment', 'postId',
			'order'=>'comments.createTime'),
		'tagFilter'=>array(self::MANY_MANY, 'Tag', 'PostTag(postId, tagId)',
			'together'=>true,
			'joinType'=>'INNER JOIN',
			'condition'=>'tagFilter.name=:tag'),
	);
}
~~~

The above relations state that

 * A post belongs to an author whose class is `User` and the relationship is established based on the `authorId` attribute value of the post;
 * A post has many comments whose class is `Comment` and the relationship is established based on the `postId` attribute value of the comments. These comments should be sorted according to their creation time.

The `tagFilter` relation is a bit complex. It is used to explicitly join the `Post` table with the `Tag` table and choose only the rows with a specified tag name. We will show how to use this relation when we implement the post display feature.

With the above relation declaration, we can easily access the author and comments of a post like the following:

~~~
[php]
$author=$post->author;
echo $author->username;

$comments=$post->comments;
foreach($comments as $comment)
	echo $comment->content;
~~~

For more details about how to declare and use relations, please refer to [the Guide](http://www.yiiframework.com/doc/guide/database.arr).


Representing Status in Text
---------------------------

Because the status of a post is stored as an integer in the database, we need to provide a text representation so that it is more intuitive when being displayed to end users. For this reason, we modify the `Post` model as follows,

~~~
[php]
class Post extends CActiveRecord
{
	const STATUS_DRAFT=0;
	const STATUS_PUBLISHED=1;
	const STATUS_ARCHIVED=2;

	......

	public function getStatusOptions()
	{
		return array(
			self::STATUS_DRAFT=>'Draft',
			self::STATUS_PUBLISHED=>'Published',
			self::STATUS_ARCHIVED=>'Archived',
		);
	}

	public function getStatusText()
	{
		$options=$this->statusOptions;
		return isset($options[$this->status]) ? $options[$this->status]
			: "unknown ({$this->status})";
	}
}
~~~

In the above, we define class constants to represent the possible status values. These constants are mainly used in the code to make it more maintainable. We also define the `getStatusOptions()` method which returns a mapping between status integer values and text display. And finally, we define the `getStatusText()` method which simply returns the textual status display of the current post.

<div class="revision">$Id$</div>