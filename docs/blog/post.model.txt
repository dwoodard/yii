Customizing Post Model
======================

The `Post` model class generated by the `yiic` tool mainly needs to be modified in three places:

 - the `rules()` method: specifies the validation rules for the model attributes;
 - the `relations()` method: specifies the related objects;
 - the `safeAttributes()` method: specifies which attributes can be massived assigned (mainly used when passing user input to the model);

> Info: A [model](http://www.yiiframework.com/doc/guide/basics.model) consists of a list of attributes, each associated with a column in the corresponding database table. Attributes can be declared explicitly as class member variables or implicitly without any declaration.


Customizing `rules()` Method
----------------------------

We first customize the validation rules that are generated by the `yiic` tool. The validation rules ensure that user inputs fulfill certain requirements before they are saved to the database. For example, the `status` attribute should be an integer 0, 1 or 2. The default rules generated by the `yiic` tool are based on the table column information and may not satisfy the actual requirements.

Based on the requirements analysis, we modify the `rules()` method as follows:

~~~
[php]
public function rules()
{
	return array(
		array('title, content, status', 'required'),
		array('title', 'length', 'max'=>128),
		array('status', 'in', 'range'=>array(0, 1, 2)),
		array('tags', 'match', 'pattern'=>'/^[\w\s,]+$/',
			'message'=>'Tags can only contain word characters.'),
	);
}
~~~

In the above, we specify that the `title`, `length` and `max` attributes are required; the length of `title` should not exceed 128; the `status` attribute value should be 0 (draft), 1 (published) or 2 (archived); and the `tags` attribute should only contain word characters and commas. All other attributes (e.g. `id`, `createTime`) will not be validated because their values do not come from user input.

After making these changes, we can visit the post creation page again to verify the new validation rules are taking effect.

> Info: Validation rules are used when we call the [validate()|CModel::validate] or [save()|CActiveRecord::save] method of the model instance.


Customizing `safeAttributes()` Method
-------------------------------------

We then customize the `safeAttributes()` method to specify which attributes can be massively assigned. When passing user inputs to the model instance, we often use the following massive assignment to simplify our code:

~~~
[php]
$model->attributes=$_POST['Post'];
~~~

Without using the above massive assignment, we would end up with the following lengthy code:

~~~
[php]
$model->title=$_POST['Post']['title'];
$model->content=$_POST['Post']['content'];
......
~~~

Although massive assignment is very convenient, it has a potential danger that a malicious user may attempt to populate an attribute whose value should remain read only or should only be changed by developer in code. For example, the `id` of the post currently being updated should not be changed.

To prevent from such danger, we would customize the `safeAttributes()` as follows, which states only `title`, `content`, `status` and `tags` attributes can be massively assigned:

~~~
[php]
public function safeAttributes()
{
	return array('title', 'content', 'status', 'tags');
}
~~~

> Tip: An easy way to identity which attributes should be put in the safe list is by observing the HTML form that is used to collect user input. Model attributes that appear in the form to receive user input may be declared as safe. Since these attributes receive input from end users, they usually should be associated with some validation rules.


Customizing `relations()` Method
--------------------------------

Lastly we customize the `relations()` method to specify the related objects of a post. By declaring these related objects in `relations()`, we can exploit the powerful [Relational ActiveRecord (RAR)](http://www.yiiframework.com/doc/guide/database.arr) feature to access the relation information of a post, such as its author and comments, without writing complex SQL JOIN statements.

We customize the `relations()` method as follows:

~~~
[php]
public function relations()
{
	return array(
		'author'=>array(self::BELONGS_TO, 'User', 'authorId'),
		'comments'=>array(self::HAS_MANY, 'Comment', 'postId',
			'order'=>'??.createTime'),
		'tagFilter'=>array(self::MANY_MANY, 'Tag', 'PostTag(postId, tagId)',
			'joinType'=>'INNER JOIN', 'condition'=>'??.name=:tag'),
	);
}
~~~

The above relations state that

 * A post belongs to an author whose class is `User` and the relationship is established based on the `authorId` attribute value of the post;
 * A post has many comments whose class is `Comment` and the relationship is established based on the `postId` attribute value of the comments. These comments should be sorted according to their creation time.
 * We will explain the `tagFilter` relation in the next section.

For more details about how to declare relations, please refer to [the Guide](http://www.yiiframework.com/doc/guide/database.arr).

With the above relation declaration, we can easily access the author and comments of a post like the following:

~~~
[php]
$author=$post->author;
echo $author->username;

$comments=$post->comments;
foreach($comments as $comment)
	echo $comment->content;
~~~


<div class="revision">$Id$</div>