Customizing CRUD Operations
===========================

With the `Post` model ready, we need to fine-tune the actions and views for the controller `PostController`.


Customizing Access Control
--------------------------

The first thing we want to do is to customize the [access control](http://www.yiiframework.com/doc/guide/topics.auth#access-control-filter) so that we can see the `admin` page. The default access control generated by the `yiic` tool only allows a user named `admin` to access that page.

We modify the `accessRules()` method in `PostController` as follows,

~~~
[php]
public function accessRules()
{
	return array(
		array('allow',  // allow all users to perform 'list' and 'show' actions
			'actions'=>array('list', 'show'),
			'users'=>array('*'),
		),
		array('allow', // allow authenticated users to perform any action
			'users'=>array('@'),
		),
		array('deny',  // deny all users
			'users'=>array('*'),
		),
	);
}
~~~

The above rules state that all users can access the `list` and `show` actions, and authenticated users can access any actions, including the `admin` action. The user should be denied access in any other scenario.


Customizing `admin` Operation
-----------------------------

The only thing that we need to customize about the `admin` operation is its view file `/wwwroot/blog/protected/views/post/admin.php`. We modify this file by removing those unwanted columns and formatting the display of date values.


Customizing `show` Operation
----------------------------

We now modify the `show` action's view file `/wwwroot/blog/protected/views/post/show.php` so that it displays a post like what we see in the [blog demo](http://www.yiiframework.com/demos/blog/). The new view should display the status of a post. Instead of displaying it as the integer value, we would like to show more meaningful text display, such as `published`, `archived`. We can place this logic in the view, but a better approach is to define a `statusText` property in the `Post` model which should return the text string corresponding to the current status value.

~~~
[php]
class Post extends CActiveRecord
{
	const STATUS_DRAFT=0;
	const STATUS_PUBLISHED=1;
	const STATUS_ARCHIVED=2;

	......

	public function getStatusOptions()
	{
		return array(
			self::STATUS_DRAFT=>'Draft',
			self::STATUS_PUBLISHED=>'Published',
			self::STATUS_ARCHIVED=>'Archived',
		);
	}

	public function getStatusText()
	{
		$options=$this->statusOptions;
		return isset($options[$this->status]) ? $options[$this->status]
			: "unknown ({$this->status})";
	}
}
~~~

In the above, we declare class constants to represent the status values, and we define `getStatusOptions()` and `getStatusText()` methods to translate status value from integers to text strings.

Because a post can be published or unpublished, and guest users should only see published posts, we also need to modify the `loadPost()` method in the `PostController` class. In particular, if `Yii::app()->user->isGuest` is true and the requested post's status is not 1 (published), we would throw an HTTP exception.

> Tip: Yii captures HTTP exceptions (instances of [CHttpException]) and displays them in error pages using some predefined templates. These templates can be customized per application, which we will describe in detail at the end of this tutorial.


Customizing `list` Operation
----------------------------

Like the `show` operation, we customize `list` in two places: the `actionList()` method in `PostController` and the view file `/wwwroot/blog/protected/views/post/list.php`. Our customization will mainly be based on the following two requirements:

 * The posts should be displayed according to their creation time with the most recent posts being displayed first.
 * The system should also be able to display posts with a specified tag.

To fulfill these requirements, we modify the `actionList()` method in `PostController` as follows,

~~~
[php]
public function actionList()
{
	$criteria=new CDbCriteria;
	$criteria->condition='status='.Post::STATUS_PUBLISHED;
	$criteria->order='createTime DESC';

	$withOption=array('author');
	if(!empty($_GET['tag']))
	{
		$withOption['tagFilter']['params'][':tag']=$_GET['tag'];
		$postCount=Post::model()->with($withOption)->count($criteria);
	}
	else
		$postCount=Post::model()->count($criteria);

	$pages=new CPagination($postCount);
	$pages->applyLimit($criteria);

	$posts=Post::model()->with($withOption)->together(true)->findAll($criteria);

	$this->render('list',array(
		'posts'=>$posts,
		'pages'=>$pages,
	));
}
~~~

In the above, we first create a query criteria which specifies only published posts should be listed and they should be sorted according to their creation time in descending order. We then compute the total number of posts satisfying the criteria. The number is used by the pagination component to correctly compute how many pages the posts should be displayed in. Finally, we retrieve the post data from the database and send them to the `list` view for display.

Notice that when there is `tag` GET parameter, we would query with the `tagFilter` using the corresponding GET parameter value. We also call `together(true)` to ensure that only a single SQL JOIN statement is used to retrieve the posts with the specified tag. Without this call, Yii would break the query into two separate SQL statements (for efficiency concern) and would return incorrect results.


Customizing `create` and `update` Operations
--------------------------------------------

The `create` and `update` operations are very similar. They both need to display an HTML form to collect user inputs, validate them, and save them into database. The main difference is that the `update` operation will pre-populate the form with the existing post data found in the database. For this reason, the `yiic` tool generates a partial view `/wwwroot/blog/protected/views/post/_form.php` that is embedded in both the `create` and `update` views to render the needed HTML form.

We first change the `_form.php` file so that the HTML form only collects the inputs we want: `title`, `content` and `status`. We use plain text fields to collect inputs for the first two attributes, and a dropdown list to collect input for `status`. The dropdown list options are the text displays of possible post statuses:

~~~
[php]
<?php echo CHtml::activeDropDownList($post,'status',Post::model()->statusOptions); ?>
~~~

We then modify the `Post` class so that it can automatically set some attributes (e.g. `createTime`, `authorId`) before a post is saved to the database. We override the `beforeValidate()` method as follows,

~~~
[php]
protected function beforeValidate($on)
{
	$parser=new CMarkdownParser;
	$this->contentDisplay=$parser->safeTransform($this->content);
	if($this->isNewRecord)
	{
		$this->createTime=$this->updateTime=time();
		$this->authorId=Yii::app()->user->id;
	}
	else
		$this->updateTime=time();
	return true;
}
~~~

The method will be invoked automatically when we call `validate()` or `save()` method of the model. In this method, we use [CMarkdownParser] to convert the content from [Markdown format](http://daringfireball.net/projects/markdown/) into HTML and save the result to `contentDisplay`. This avoids repeated format conversion when we display a post. If the post is new, we set its `createTime` and `authorId` attributes; otherwise we set its `updateTime` to be the current time.

Because we want to save post tags to the `Tag` table, we also need the following method in the `Post` class, which is invoked automatically after a post is saved to the database:

~~~
[php]
protected function afterSave()
{
	if(!$this->isNewRecord)
		$this->dbConnection->createCommand(
			'DELETE FROM PostTag WHERE postId='.$this->id)->execute();

	foreach($this->getTagArray() as $name)
	{
		if(($tag=Tag::model()->findByAttributes(array('name'=>$name)))===null)
		{
			$tag=new Tag(array('name'=>$name));
			$tag->save();
		}
		$this->dbConnection->createCommand(
			"INSERT INTO PostTag (postId, tagId) VALUES ({$this->id},{$tag->id})")->execute();
	}
}
~~~

In the above, we first clean up the `PostTag` table for rows related with the current post. We then insert new tags into the `Tag` table and add a reference in the `PostTag` table.

> Tip: It is good practice to keep business logic, such as the above `beforeValidate()` and `afterSave()` code, in model classes.


Implementing Preview Feature
----------------------------

Besides the above customizations, we also want to add the preview feature that would allow us to preview a post before we save it to the database.

We first change the `_form.php` view file to add a `preview` button and a preview display. The preview is only displayed when the preview button is clicked and there is not validation error.

~~~
[php]
<?php echo CHtml::submitButton('Preview',array('name'=>'previewPost')); ?>
......
<?php if(isset($_POST['previewPost']) && !$post->hasErrors()): ?>
...display preview of $post here...
<?php endif; ?>
~~~

We then change the `actionCreate()` and `actionUpdate()` methods of `PostController` to respond to the preview request. Below we show the updated code of `actionCreate()`, which is very similar to that in `actionUpdate()`:

~~~
[php]
public function actionCreate()
{
	$post=new Post;
	if(isset($_POST['Post']))
	{
		$post->attributes=$_POST['Post'];
		if(isset($_POST['previewPost']))
			$post->validate();
		else if(isset($_POST['submitPost']) && $post->save())
			$this->redirect(array('show','id'=>$post->id));
	}
	$this->render('create',array('post'=>$post));
}
~~~

In the above, if the preview button is clicked, we call `$post->validate()` to validate the user input; otherwise if the submit button is clicked, we try to save the post by calling `$post->save()` which implicitly performs validation. If the saving is successful (no validation errors and the data is saved to the database without error), we redirect the user browser to show the newly created post.

<div class="revision">$Id$</div>